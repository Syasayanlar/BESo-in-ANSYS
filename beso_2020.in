! ========================================================================
! ANSYS APDL Code for BESO with Dual P-Norm Aggregation
! Augmented Lagrangian Optimization
! ========================================================================
! Features:
! - Analytical compliance sensitivity
! - P-norm aggregated stress constraint with analytical sensitivity
! - P-norm aggregated displacement constraint with analytical sensitivity
! - All constraints active from iteration 1
! - Volume, stress, and displacement constraints
! - Design/Passive domain management
! - FULLY ANALYTICAL - NO NUMERICAL DIFFERENTIATION
! ========================================================================
!
! P-NORM AGGREGATION METHOD - THEORETICAL BACKGROUND
! ===================================================
! 
! The p-norm aggregation provides a smooth, differentiable approximation
! to maximum constraints, enabling efficient analytical sensitivity
! computation without expensive numerical differentiation.
!
! STRESS FORMULATION:
! -------------------
! Instead of max(σ_i) ≤ σ_limit, we use:
!   σ_pnorm = σ_ref × (Σ(σ_i/σ_ref)^p)^(1/p) ≤ σ_limit
!
! DISPLACEMENT FORMULATION:
! -------------------------
! Instead of max(d_i) ≤ d_limit, we use:
!   d_pnorm = d_ref × (Σ(d_i/d_ref)^p)^(1/p) ≤ d_limit
! where d_i = √(ux² + uy² + uz²) at each node
!
! PROPERTIES:
! -----------
! • As p → ∞, p-norm → exact maximum
! • For stress: p = 8 typical (sharp local peaks)
! • For displacement: p = 6 typical (smoother field distribution)
! • Higher p = tighter bound but steeper gradients
! • Lower p = smoother but looser bound
!
! ANALYTICAL SENSITIVITIES:
! -------------------------
! Stress: ∂σ_pnorm/∂x_i = (σ_i/σ_pnorm)^(p-1) × (σ_ref/σ_pnorm) × ∂σ_i/∂x_i
! Displ:  ∂d_pnorm/∂x_e = Σ_nodes[(d_j/d_pnorm)^(p-1) × (d_ref/d_pnorm) × ∂d_j/∂x_e]
!
! COMPUTATIONAL EFFICIENCY:
! -------------------------
! Numerical differentiation:  2N FEA solves per iteration (stress + displ)
! Dual P-norm aggregation:    1 FEA solve per iteration
! Speedup factor:             ~2N (e.g., 3000× for N=1500 elements)
!
! REFERENCES:
! -----------
! 1. Kennedy, G.J. & Hicken, J.E. (2015)
!    "Improved constraint-aggregation methods"
!    Computer Methods in Applied Mechanics and Engineering, 289, 332-354
!    DOI: 10.1016/j.cma.2015.02.017
!
! 2. Le, C., Norato, J., Bruns, T., Ha, C., & Tortorelli, D. (2010)
!    "Stress-based topology optimization for continua"
!    Structural and Multidisciplinary Optimization, 41(4), 605-620
!    DOI: 10.1007/s00158-009-0424-y
!
! 3. París, J., Navarrina, F., Colominas, I., & Casteleiro, M. (2009)
!    "Topology optimization of continuum structures with local and 
!     global stress constraints"
!    Structural and Multidisciplinary Optimization, 39(4), 419-437
!    DOI: 10.1007/s00158-008-0336-2
!
! 4. Holmberg, E., Torstenfelt, B., & Klarbring, A. (2013)
!    "Stress constrained topology optimization"
!    Structural and Multidisciplinary Optimization, 48(1), 33-47
!    DOI: 10.1007/s00158-012-0880-7
!
! 5. da Silva, G.A., Beck, A.T., & Sigmund, O. (2019)
!    "Stress-constrained topology optimization considering uniform 
!     manufacturing uncertainties"
!    Computer Methods in Applied Mechanics and Engineering, 344, 512-537
!    DOI: 10.1016/j.cma.2018.10.020
!
! 6. Kreisselmeier, G. & Steinhauser, R. (1979)
!    "Systematic Control Design by Optimizing a Vector Performance Index"
!    IFAC Symposium on Computer Aided Design of Control Systems
!
! ========================================================================
/BATCH
FINISH
/CLEAR, NOSTART

/FILENAME, beso_2020, 1
/COM, BESO Topology Optimization with Augmented Lagrange for Volume, Stress and Displacement Constraints
/COM, Modified by Suleyman Yasayanlar 2026
/COM, Be aware of units used in the model (N, mm)
/COM, Be aware of material numbers for design and passive domains
/COM, Material 1 : Design Material
/COM, Material 2 : Void Material
/COM, If submodel please add cut BCs in Section 3

/COM, Clear all previous data
! Delete old result files
/SYS, del *.esav
/SYS, del *.full
/SYS, del *.mntr
/SYS, del *.page
/SYS, del *.rst
/SYS, del *.stat
/SYS, del *.db
/SYS, del *.lock
! ========================================================================
! SECTION 1: INPUT PARAMETERS
!  MATERIAL PROPERTIES, MESH SIZE, BESO PARAMETERS
! ========================================================================
! ---   Constants   ---
_PI = acos(-1)
eps_machine = 1E-16            ! Machine epsilon for numerical differentiation

! --- Material Properties ---
E_design       = 200e3               ! Young's Modulus (MPa)
nu_design      = 0.3                 ! Poisson's Ratio
void_param     = 1e-9                ! Void material parameter
E_void         = void_param*E_design       ! Void Young's Modulus (MPa)
nu_void        = nu_design           ! Void Poisson's Ratio

! --- Mesh Parameters ---
/COM, Element size and filter radius must be double checked with FEA model
esize_ = 20                     ! Element size (mm)
Rmin  = esize_*1.5              ! Filter radius for sensitivity smoothing

! --- BESO Parameters ---
volfrac = 0.25                 ! Target volume fraction (25%)
ER      = 0.05                 ! Evolution rate (5% per iteration)
maxIter = 100                  ! Maximum number of iterations
convTol = 0.002                ! Convergence tolerance (0.2%)
conv_window = 5                ! Convergence window (iterations)
xmin    = 0.001                ! Minimum density to avoid singularity

! --- Constraint Parameters ---
stress_limit = 420             ! Maximum allowable von Mises stress (Pa) = 420 MPa
displ_limit_RMS = 50           ! RMS displacement limit (mm)
tol_constraint = 0.05          ! Constraint tolerance (5% violation acceptable)

! --- P-Norm Aggregation Parameters ---
p_norm_stress = 8.0            ! P-norm for stress (recommended: 6-12)
                               ! p=6:  smoother, ~15-20% error
                               ! p=8:  balanced, ~5-10% error (RECOMMENDED)
                               ! p=10: tighter, ~2-5% error
                               ! p=12: very tight, ~1-3% error (may be stiff)

p_norm_displ = 6.0             ! P-norm for displacement (recommended: 4-8)
                               ! Lower p for displacement (smoother field)
                               ! p=4:  very smooth, ~20-30% error
                               ! p=6:  balanced (RECOMMENDED)
                               ! p=8:  tight, ~5-10% error

sigma_ref = stress_limit       ! Reference stress for normalization
displ_ref = displ_limit_RMS    ! Reference displacement for normalization

! --- Augmented Lagrangian Parameters ---
lambda_stress = 0              ! Stress constraint multiplier
lambda_displ = 0               ! Displacement constraint multiplier

mu_stress = 1E-8               ! Stress penalty parameter
mu_displ = 1E-8                ! Displacement penalty parameter
mu_max = 1E-4                  ! Maximum penalty parameter
mu_update = 10                 ! Penalty update factor
lambda_update = 0.5            ! Lagrange multiplier update rate

! --- LCF (Low Cycle Fatigue) Constraint Parameters (COMMENTED OUT - TO BE IMPLEMENTED) ---
! lcf_cycles_min = 1000         ! Minimum required LCF life (cycles)
! p_norm_lcf = 6.0              ! P-norm for LCF aggregation (recommended: 4-8)
! lambda_lcf = 0                ! LCF constraint multiplier
! mu_lcf = 1E-8                 ! LCF penalty parameter
! stress_mean = 0               ! Mean stress for LCF calculation (MPa)
! stress_amplitude_ref = 200E6  ! Reference stress amplitude (Pa)
! temperature = 293             ! Operating temperature (K) for LCF
! material_b = -0.12            ! Fatigue strength exponent (typical for steel)
! material_c = -0.6             ! Fatigue ductility exponent (typical for steel)
! material_Sf_prime = 1000E6    ! Fatigue strength coefficient (Pa)
! material_Ef_prime = 0.5       ! Fatigue ductility coefficient
!
! LCF FORMULATION:
! ----------------
! Basquin-Coffin-Manson equation:
!   Δε/2 = (σ'_f/E)(2N)^b + ε'_f(2N)^c
!
! P-norm aggregation for minimum life:
!   N_pnorm = N_ref × (Σ(N_ref/N_i)^p)^(1/p)
!   Constraint: N_pnorm ≥ N_min
!
! REFERENCES:
!   - Suresh, S. (1998). "Fatigue of Materials" Cambridge University Press
!   - Dowling, N.E. (2012). "Mechanical Behavior of Materials" Pearson
!   - Holmen, J.K. et al. (2017). "Topology optimization with fatigue
!     constraints" Structural and Multidisciplinary Optimization, 56(5)

/COM, ========================================================================
/PREP7
! --- Define Material --- 
! material 1 : Design Material
! material 2 : Void Material
MPTEMP,,,,,,,,  
MPTEMP,1,0  
MPDATA,EX,1,,E_design 
MPDATA,PRXY,1,,nu_design

MPTEMP,,,,,,,,  
MPTEMP,1,0  
MPDATA,EX,2,,E_void 
MPDATA,PRXY,2,,nu_void

ALLSEL
FINISH
! ========================================================================
! SECTION 2: READ MODEL AND INITIAL MESH
! BE AWARE OF UNITS USED IN THE MODEL (N, mm)
! GE case : IN and PSI
! ========================================================================
/input, simple_block, cdb, '.'
/PREP7
ALLSEL

/COM, For initial study all numberings are reset
NUMCMP,ALL  

EPLOT
/title, Initial Mesh -- BESO Topology Optimization with Augmented Lagrange (N.mm)
FINISH

! ========================================================================
! SECTION 3: APPLY MATERIALS, BOUNDARY CONDITIONS AND LOADS
! If this is a submodel this is location where you apply Cut BCs
! ========================================================================
ALLSEL
/PREP7
! --- Assign Material to Elements ---
/COM, If you have other domains please assign materials accordingly
ESEL,ALL
EMODIF,ALL,,MAT,1

! --- Boundary Conditions ---
! --- User must update these based on model ---
nsel,s,,,FIXED_BC
d,all,all,0

nsel,s,,,FORCE_BC
F,all,fz,-1e7/16      ! Total force of -1e7 N distributed over 16 nodes

ALLSEL
FINISH
! ========================================================================
! SECTION 4: INITIALIZE ARRAYS AND VARIABLES
! ========================================================================
/PREP7
ALLSEL

! Get element and node counts
*GET, numElem, ELEM, 0, COUNT
*GET, numNode, NODE, 0, COUNT

ESEL,s,,,DESIGN_DOMAIN
*GET, numDesignElem, ELEM, 0, COUNT
ALLSEL

ESEL,s,,,PASSIVE_REGION
*GET, numPassiveElem, ELEM, 0, COUNT
ALLSEL

/COM, ========================================
/COM, BESO WITH DUAL P-NORM AGGREGATION
/COM, Total Elements: %numElem%
/COM, Total Nodes: %numNode%
/COM, Design Domain Elements: %numDesignElem%
/COM, Passive Region Elements: %numPassiveElem%
/COM, Units are N and mm
/COM, For later cases we can use in and psi units
/COM, Volume Fraction Target: %volfrac%
/COM, Evolution Rate: %ER% per iteration
/COM, Maximum Iterations: %maxIter%
/COM, Convergence Tolerance: %convTol%
/COM, P-Norm Stress: %p_norm_stress%
/COM, P-Norm Displacement: %p_norm_displ%
/COM, Stress Limit: %stress_limit% MPa
/COM, Displacement Limit: %displ_limit_RMS% mm
/COM, ========================================

! --- Element density and sensitivity arrays ---
*DIM, xe, ARRAY, numElem
*DIM, sensit_C, ARRAY, numElem              ! Compliance sensitivity
*DIM, sensit_g_stress, ARRAY, numElem       ! P-norm stress sensitivity
*DIM, sensit_g_displ, ARRAY, numElem        ! P-norm displacement sensitivity
*DIM, sensit_combined, ARRAY, numElem
*DIM, sensit_filt, ARRAY, numElem
*DIM, sensit_old, ARRAY, numElem

! --- Element geometry arrays ---
*DIM, elemCenX, ARRAY, numElem
*DIM, elemCenY, ARRAY, numElem
*DIM, elemCenZ, ARRAY, numElem
*DIM, elemVol, ARRAY, numElem

! --- Optimization history arrays ---
*DIM, compliance, ARRAY, maxIter
*DIM, volHistory, ARRAY, maxIter
*DIM, stressPnormHistory, ARRAY, maxIter    ! P-norm aggregated stress
*DIM, maxStressHistory, ARRAY, maxIter      ! Actual maximum (for comparison)
*DIM, displPnormHistory, ARRAY, maxIter     ! P-norm aggregated displacement
*DIM, maxDisplHistory, ARRAY, maxIter       ! Actual maximum displacement

! --- Augmented Lagrangian tracking ---
*DIM, lambdaStressHistory, ARRAY, maxIter
*DIM, lambdaDisplHistory, ARRAY, maxIter
*DIM, muStressHistory, ARRAY, maxIter
*DIM, muDisplHistory, ARRAY, maxIter
*DIM, g_stressHistory, ARRAY, maxIter
*DIM, g_displHistory, ARRAY, maxIter
*DIM, g_volHistory, ARRAY, maxIter
*DIM, pnormErrorStress, ARRAY, maxIter      ! P-norm stress approximation error
*DIM, pnormErrorDispl, ARRAY, maxIter       ! P-norm displ approximation error

! --- Constraint arrays ---
*DIM, elemStress, ARRAY, numElem

! --- LCF arrays (COMMENTED OUT - TO BE IMPLEMENTED) ---
! *DIM, elemLCF, ARRAY, numElem             ! LCF life (cycles) per element
! *DIM, elemStressAmp, ARRAY, numElem       ! Stress amplitude per element
! *DIM, sensit_g_lcf, ARRAY, numElem        ! LCF constraint sensitivity
! *DIM, lcfPnormHistory, ARRAY, maxIter     ! P-norm aggregated LCF life
! *DIM, minLCFHistory, ARRAY, maxIter       ! Minimum LCF life (for comparison)
! *DIM, lambdaLCFHistory, ARRAY, maxIter    ! LCF multiplier history
! *DIM, muLCFHistory, ARRAY, maxIter        ! LCF penalty history
! *DIM, g_lcfHistory, ARRAY, maxIter        ! LCF constraint violation
! *DIM, pnormErrorLCF, ARRAY, maxIter       ! LCF p-norm approximation error

! --- Nodal displacement arrays ---
*DIM, nodeDispX, ARRAY, numNode
*DIM, nodeDispY, ARRAY, numNode
*DIM, nodeDispZ, ARRAY, numNode
*DIM, nodeDisplMag, ARRAY, numNode          ! Displacement magnitude per node

! --- BC nodes flag ---
*DIM, isBCNode, ARRAY, numNode

! --- Estimate max neighbors per element based on filter radius --- 
numNeighIncrease = 100                          ! Safety buffer for neighbor count  
maxNeighbors = NINT((4/3)*_PI*(Rmin/esize_)**3)*4 + numNeighIncrease  
maxNeighbors = maxNeighbors + numNeighIncrease  ! Ensure enough space
*DIM, neighCount, ARRAY, numElem                ! Number of neighbors for each element
*DIM, neighList, ARRAY, numElem, maxNeighbors   ! Neighbor element indices
*DIM, neighWeight, ARRAY, numElem, maxNeighbors ! Neighbor weights (cone filter)

*DIM, isDesign, ARRAY, numElem     ! Design domain flag (1=design, 0=passive)

! Initialize all elements as solid (xe = 1)
*VFILL, xe(1), RAMP, 1.0, 0

! Store element centroids and volumes
ALLSEL
*VGET, elemCenX(1), ELEM, 1, CENT, X
*VGET, elemCenY(1), ELEM, 1, CENT, Y
*VGET, elemCenZ(1), ELEM, 1, CENT, Z
*VGET, elemVol(1), ELEM, 1, GEOM           ! Element volume


! ========================================================================
! PRE-COMPUTE NEIGHBOR LIST FOR SENSITIVITY FILTER
! ========================================================================
allsel
/COM, Pre-computing neighbor list for 3D filter...
*DO, i, 1, numElem
    neighCount(i) = 0
    
    ! Get center of current element
    cx_i = elemCenX(i)
    cy_i = elemCenY(i)
    cz_i = elemCenZ(i)

    ! Select nodes within filter radius using spatial queries
    ALLSEL
    NSEL, S, LOC, X, cx_i - Rmin, cx_i + Rmin
    NSEL, R, LOC, Y, cy_i - Rmin, cy_i + Rmin
    NSEL, R, LOC, Z, cz_i - Rmin, cz_i + Rmin
    
    ! Select elements attached to these nodes
    ESLN, S, 1

    ! Get the count of selected elements
    *GET, numNeigh, ELEM, 0, COUNT
    
    ! Loop over selected neighbor elements and calculate weights
    *IF, numNeigh, GT, 0, THEN
        *GET, j, ELEM, 0, NUM, MIN
        
        *DO, k, 1, numNeigh
            ! Calculate 3D distance from current element to neighbor
            dx = elemCenX(j) - cx_i
            dy = elemCenY(j) - cy_i
            dz = elemCenZ(j) - cz_i
            dist = SQRT(dx*dx + dy*dy + dz*dz)
            
            ! If within filter radius, store neighbor and weight
            *IF, dist, LT, Rmin, THEN
                neighCount(i) = neighCount(i) + 1
                nc = neighCount(i)
                
                ! Store neighbor ID and weight (cone filter: w = Rmin - dist)
                neighList(i, nc) = j
                neighWeight(i, nc) = Rmin - dist
                
                ! Safety check: don't exceed array size
                *IF, nc, GE, maxNeighbors, THEN
                    *EXIT
                *ENDIF
            *ENDIF
            
            ! Get next element in selection
            *IF, k, LT, numNeigh, THEN
                *GET, j, ELEM, j, NXTH
            *ENDIF
        *ENDDO
    *ENDIF
    
    ! Progress indicator
    *IF, MOD(i, 500), EQ, 0, THEN
        /COM, Processed element %i% of %numElem%
    *ENDIF
*ENDDO

ALLSEL
/COM, Neighbor list computed.

! ========================================================================
! SECTION 4.1: DEFINE DESIGN AND PASSIVE REGIONS
! ========================================================================
numDesignElem = 0                 ! Counter for design elements
numPassiveElem = 0                ! Counter for passive elements

! if isDesign(i) = 1 then element is in design domain
! else in passive region
! Initialize all elements in design domain
*VFILL, isDesign(1), RAMP, 1.0, 0

! update isDesign array based on geometry
! here only change passive region near BC and load point
! be aware those must be defined in set.
! Passive element set: PASSIVE_REGION 
esel,s,,,PASSIVE_REGION 
*GET, numPassiveElem, ELEM, NUM, COUNT
*get, curr_elem, ELEM, 0, NUM, MIN

*DO, i, 1, numPassiveElem
    isDesign(curr_elem) = 0
    *GET, curr_elem, ELEM, curr_elem, NXTH
    numPassiveElem = numPassiveElem + 1
*ENDDO

esel,s,,,DESIGN_DOMAIN 
*GET, numDesignElem, ELEM, NUM, COUNT 

/COM, ========================================
/COM, ELEMENT & NODE NUMBERS ARE RESET INITALLY
/COM, DOMAIN INFORMATION:
/COM, Total Elements: %numElem%
/COM, Design Elements: %numDesignElem%
/COM, Passive Elements: %numElem - numDesignElem%
/COM, ========================================

! Create design element index list for fast iteration
*DIM, designElemIdx, ARRAY, numDesignElem   ! Indices of design elements
idx = 0

esel,s,,,DESIGN_DOMAIN 
*GET, n_el, ELEM, NUM, COUNT
*get, curr_elem, ELEM, 0, NUM, MIN

*DO, i, 1, n_el
    idx = idx + 1
    designElemIdx(idx) = curr_elem
    *GET, curr_elem, ELEM, curr_elem, NXTH  
*ENDDO

ALLSEL

! Initialize volume
totalVol   = numDesignElem
currentVol = numDesignElem

FINISH

/COM, ========================================================================
/COM, DESIGN SETUP COMPLETE. READY FOR OPTIMIZATION LOOP.
/COM, PLEASE CHECK BCs, LOADS, MATERIALS BEFORE PROCEEDING.
/COM, ELEMENTS IN DESIGN DOMAIN: %numDesignElem%
/COM, ELEMENTS IN PASSIVE REGION: %numPassiveElem%
/COM, OPTIMIZATION WILL BE PERFORMED IN DESIGN_DOMAIN ONLY.
/COM, IF YOU WANT YOU CAN ALWAYS TWEAK OPTIMIZATION PARAMETERS IN beso_2020.in
/COM, ========================================================================

! ========================================================================
! SECTION 4.2: INITIALIZE CSV OUTPUT FILES
! ========================================================================
! TODO: Update CSV headers for new variables

! ========================================================================
! SECTION 5: MAIN BESO OPTIMIZATION LOOP - ALL CONSTRAINTS ACTIVE
! ========================================================================
change = 0          ! Initialize change variable
converged = 0       ! Convergence flag (0=no, 1=yes)

/COM, ========================================
/COM, STARTING BESO OPTIMIZATION - ALL CONSTRAINTS ACTIVE
/COM, ========================================

*DO, iter, 1, maxIter ! limit iterations for only 1 to cechk errors initially
    ! ==================================================================
    ! 5.1: UPDATE MATERIAL PROPERTIES BASED ON ELEMENT DENSITIES
    ! ==================================================================
    /PREP7
    
    ! Passive elements always solid
    cmsel,s,PASSIVE_REGION
    emodif,all,mat,1

    esel,s,,,DESIGN_DOMAIN
    *GET, n_el, ELEM, NUM, COUNT
    *get, curr_elem, ELEM, 0, NUM, MIN

   ! Design elements: assign material based on density
    *DO, i, 1, n_el
        *if, xe(curr_elem), LT, 0.5, THEN
            emodif,curr_elem,mat,2 ! void material
        *ELSE
            emodif,curr_elem,mat,1 ! solid material
        *ENDIF
        *GET, curr_elem, ELEM, curr_elem, NXTH  ! choose next element
    *ENDDO    
    ALLSEL
    FINISH

    ! ==================================================================
    ! 5.2: SOLVE FEA (ONLY ONE SOLVE PER ITERATION!)
    ! ==================================================================
    /SOLU
    ANTYPE, STATIC
    NCNV, 1, , , , , 1E10
    NEQIT, 100
    SOLVE
    FINISH

    ! ==================================================================
    ! 5.3: POST-PROCESS WITH DUAL P-NORM AGGREGATION
    ! ==================================================================
    /POST1
    SET, 1, LAST
    ! ===== select design domain only =====
    esel,s,,,DESIGN_DOMAIN

    ! ===== COMPLIANCE (ANALYTICAL) =====
    ETABLE, SENE_TAB, SENE
    SSUM
    *GET, totalSENE, SSUM, , ITEM, SENE_TAB
    compliance(iter) = 2*totalSENE
    
    ! ALLSEL
    *VGET, sensit_C(1), ELEM, 1, ETAB, SENE_TAB
    
    ! ===== P-NORM STRESS AGGREGATION =====
    ETABLE, SEQV_TAB, S, EQV
    ! ALLSEL
    *VGET, elemStress(1), ELEM, 1, ETAB, SEQV_TAB
    
    ! Find actual maximum for comparison
    *VSCFUN, maxStress, MAX, elemStress(1)
    maxStressHistory(iter) = maxStress

    ! START DEBUG FROM HERE
    ! START DEBUG FROM HERE
    ! START DEBUG FROM HERE
    ! START DEBUG FROM HERE
    ! P-NORM AGGREGATION
    ! STRESS FORMULATION:
    ! -------------------
    ! Instead of max(σ_i) ≤ σ_limit, we use:
    !   σ_pnorm = σ_ref × (Σ(σ_i/σ_ref)^p)^(1/p) ≤ σ_limit
    ! Compute p-norm aggregated stress
    sum_pnorm_stress = 0
    *DO, i, 1, numElem
        *IF, elemStress(i), GT, 1E-6, THEN
            ratio_s = elemStress(i) / sigma_ref
            sum_pnorm_stress = sum_pnorm_stress + ratio_s**p_norm_stress
        *ENDIF
    *ENDDO
    stress_pnorm = sigma_ref * (sum_pnorm_stress**(1/p_norm_stress))
    stressPnormHistory(iter) = stress_pnorm
    
    ! Calculate stress approximation error
    stress_error = (stress_pnorm - maxStress) / maxStress * 100
    pnormErrorStress(iter) = stress_error
    
    ! Stress constraint using p-norm
    g_stress = (stress_pnorm - stress_limit) / stress_limit
    g_stressHistory(iter) = g_stress

    ! ===== P-NORM ANALYTICAL STRESS SENSITIVITY =====
    *DO, i, 1, numElem
        *IF, elemStress(i), GT, 1E-6, THEN
            ratio_stress = elemStress(i) / stress_pnorm
            power_term_s = ratio_stress**(p_norm_stress - 1)
            norm_term_s = sigma_ref / stress_pnorm
            dstress_dx = elemStress(i)
            sensit_g_stress(i) = power_term_s * norm_term_s * dstress_dx / stress_limit
            
            *IF, xe(i), LT, 0.5, THEN
                sensit_g_stress(i) = sensit_g_stress(i) * 0.1
            *ENDIF
        *ELSE
            sensit_g_stress(i) = 0
        *ENDIF
    *ENDDO

    ! ===== EXTRACT NODAL DISPLACEMENTS =====
    ALLSEL
    *VGET, nodeDispX(1), NODE, 1, U, X
    *VGET, nodeDispY(1), NODE, 1, U, Y
    *VGET, nodeDispZ(1), NODE, 1, U, Z
    
    ! Identify BC nodes
    CMSEL, S, FIXED_BC
    *GET, numBCNodes, NODE, 0, COUNT
    
    *IF, numBCNodes, GT, 0, THEN
        *VFILL, isBCNode(1), RAMP, 0, 0
        *GET, bcNode, NODE, 0, NUM, MIN
        *DO, ii, 1, numBCNodes
            isBCNode(bcNode) = 1
            *IF, ii, LT, numBCNodes, THEN
                *GET, bcNode, NODE, bcNode, NXTH
            *ENDIF
        *ENDDO
    *ENDIF
    
    ALLSEL
    
    ! ===== P-NORM DISPLACEMENT AGGREGATION =====
    ! Calculate displacement magnitude for each node
    *GET, firstNode, NODE, 0, NUM, MIN
    nodeID = firstNode
    maxDispl = 0
    
    *DO, ii, 1, numNode
        *IF, numBCNodes, GT, 0, THEN
            *IF, isBCNode(nodeID), EQ, 0, THEN
                ux = nodeDispX(nodeID)
                uy = nodeDispY(nodeID)
                uz = nodeDispZ(nodeID)
                nodeDisplMag(nodeID) = SQRT(ux*ux + uy*uy + uz*uz)
                *IF, nodeDisplMag(nodeID), GT, maxDispl, THEN
                    maxDispl = nodeDisplMag(nodeID)
                *ENDIF
            *ELSE
                nodeDisplMag(nodeID) = 0
            *ENDIF
        *ELSE
            ux = nodeDispX(nodeID)
            uy = nodeDispY(nodeID)
            uz = nodeDispZ(nodeID)
            nodeDisplMag(nodeID) = SQRT(ux*ux + uy*uy + uz*uz)
            *IF, nodeDisplMag(nodeID), GT, maxDispl, THEN
                maxDispl = nodeDisplMag(nodeID)
            *ENDIF
        *ENDIF
        *IF, ii, LT, numNode, THEN
            *GET, nodeID, NODE, nodeID, NXTH
        *ENDIF
    *ENDDO
    
    maxDisplHistory(iter) = maxDispl
    
    ! Compute p-norm aggregated displacement
    sum_pnorm_displ = 0
    *GET, firstNode, NODE, 0, NUM, MIN
    nodeID = firstNode
    
    *DO, ii, 1, numNode
        *IF, nodeDisplMag(nodeID), GT, 1E-12, THEN
            ratio_d = nodeDisplMag(nodeID) / displ_ref
            sum_pnorm_displ = sum_pnorm_displ + ratio_d**p_norm_displ
        *ENDIF
        *IF, ii, LT, numNode, THEN
            *GET, nodeID, NODE, nodeID, NXTH
        *ENDIF
    *ENDDO
    
    displ_pnorm = displ_ref * (sum_pnorm_displ**(1/p_norm_displ))
    displPnormHistory(iter) = displ_pnorm
    
    ! Calculate displacement approximation error
    displ_error = (displ_pnorm - maxDispl) / maxDispl * 100
    pnormErrorDispl(iter) = displ_error
    
    ! Displacement constraint using p-norm
    g_displ = (displ_pnorm - displ_limit_RMS) / displ_limit_RMS
    g_displHistory(iter) = g_displ
    
    /COM, ========================================
    /COM, Iter %iter% Analysis:
    /COM, Compliance = %compliance(iter)%
    /COM, Max Stress = %maxStress% MPa, P-norm = %stress_pnorm% MPa (Error: %stress_error% pct)
    /COM, Max Displ = %maxDispl% mm, P-norm = %displ_pnorm% mm (Error: %displ_error% pct)
    /COM, g_stress = %g_stress*100% pct, g_displ = %g_displ*100% pct
    /COM, ========================================    

    ! ===== LCF (LOW CYCLE FATIGUE) CONSTRAINT (COMMENTED OUT - TO BE IMPLEMENTED) =====
    ! Calculate LCF life for each element using stress results
    ! 
    ! *DO, i, 1, numElem
    !     *IF, elemStress(i), GT, 1E-6, THEN
    !         ! Assume stress amplitude = von Mises / 2 (simplified)
    !         elemStressAmp(i) = elemStress(i) / 2.0
    !         
    !         ! Basquin-Coffin-Manson equation (elastic + plastic)
    !         ! Δε/2 = (σ'_f/E)(2N)^b + ε'_f(2N)^c
    !         ! Simplified: solve for N using stress amplitude
    !         
    !         stress_ratio = elemStressAmp(i) / material_Sf_prime
    !         
    !         ! Elastic component dominates for HCF, plastic for LCF
    !         ! Simplified calculation: 2N = (σ_a/σ'_f)^(1/b)
    !         two_N = (stress_ratio)**(1.0/material_b)
    !         elemLCF(i) = two_N / 2.0
    !         
    !         ! Floor at 1 cycle to avoid numerical issues
    !         *IF, elemLCF(i), LT, 1, THEN
    !             elemLCF(i) = 1
    !         *ENDIF
    !     *ELSE
    !         elemLCF(i) = 1E10  ! Very high life for low stress
    !     *ENDIF
    ! *ENDDO
    ! 
    ! ! Find minimum LCF life
    ! *VSCFUN, minLCF, MIN, elemLCF(1)
    ! minLCFHistory(iter) = minLCF
    ! 
    ! ! P-norm aggregation for minimum life (inverted)
    ! ! We want N_pnorm ≥ N_min, so aggregate 1/N instead
    ! sum_pnorm_lcf = 0
    ! lcf_ref = lcf_cycles_min
    ! 
    ! *DO, i, 1, numElem
    !     *IF, elemLCF(i), GT, 1, THEN
    !         ! Aggregate reciprocal: Σ(N_ref/N_i)^p
    !         ratio_lcf = lcf_ref / elemLCF(i)
    !         sum_pnorm_lcf = sum_pnorm_lcf + ratio_lcf**p_norm_lcf
    !     *ENDIF
    ! *ENDDO
    ! 
    ! ! Inverse p-norm: N_pnorm = N_ref / (Σ(N_ref/N_i)^p)^(1/p)
    ! lcf_pnorm = lcf_ref / (sum_pnorm_lcf**(1.0/p_norm_lcf))
    ! lcfPnormHistory(iter) = lcf_pnorm
    ! 
    ! ! LCF error
    ! lcf_error = (minLCF - lcf_pnorm) / minLCF * 100
    ! pnormErrorLCF(iter) = lcf_error
    ! 
    ! ! LCF constraint: g_lcf = (N_min - N_pnorm) / N_min
    ! ! Negative g_lcf means constraint satisfied
    ! g_lcf = (lcf_cycles_min - lcf_pnorm) / lcf_cycles_min
    ! g_lcfHistory(iter) = g_lcf
    ! 
    ! /COM, LCF Analysis:
    ! /COM, Min LCF Life = %minLCF% cycles
    ! /COM, P-norm LCF Life = %lcf_pnorm% cycles
    ! /COM, LCF Constraint: g_lcf = %g_lcf*100% pct
    
    ! ===== P-NORM ANALYTICAL DISPLACEMENT SENSITIVITY =====
    ! Map nodal p-norm sensitivity to element sensitivity
    *VFILL, sensit_g_displ(1), RAMP, 0, 0
    
    *DO, i, 1, numElem
        ESEL, S, ELEM, , i
        NSLE, S
        
        *GET, numElemNodes, NODE, 0, COUNT
        
        *IF, numElemNodes, GT, 0, THEN
            *GET, elemNode, NODE, 0, NUM, MIN
            elem_displ_sensit = 0
            
            *DO, jj, 1, numElemNodes
                *IF, nodeDisplMag(elemNode), GT, 1E-12, THEN
                    ! P-norm weight: (d_j/d_pnorm)^(p-1)
                    ratio_node = nodeDisplMag(elemNode) / displ_pnorm
                    power_term_d = ratio_node**(p_norm_displ - 1)
                    norm_term_d = displ_ref / displ_pnorm
                    
                    ! Heuristic: element contribution scaled by compliance
                    dDispl_dx = sensit_C(i) * nodeDisplMag(elemNode) / (compliance(iter) + 1E-10)
                    
                    elem_displ_sensit = elem_displ_sensit + power_term_d*norm_term_d*dDispl_dx
                *ENDIF
                
                *IF, jj, LT, numElemNodes, THEN
                    *GET, elemNode, NODE, elemNode, NXTH
                *ENDIF
            *ENDDO
            
            sensit_g_displ(i) = elem_displ_sensit/(numElemNodes*displ_limit_RMS)
            
            *IF, xe(i), LT, 0.5, THEN
                sensit_g_displ(i) = sensit_g_displ(i) * 0.1
            *ENDIF
        *ENDIF
        
        ALLSEL
    *ENDDO
    
    ALLSEL
    
    ! ===== LCF SENSITIVITY (COMMENTED OUT - TO BE IMPLEMENTED) =====
    ! P-norm analytical sensitivity for LCF constraint
    ! 
    ! *VFILL, sensit_g_lcf(1), RAMP, 0, 0
    ! 
    ! *DO, i, 1, numElem
    !     *IF, elemLCF(i), GT, 1, THEN
    !         ! P-norm weight: (N_ref/N_i)^p / N_pnorm^(p-1)
    !         ratio_lcf_elem = lcf_ref / elemLCF(i)
    !         power_term_lcf = ratio_lcf_elem**(p_norm_lcf - 1.0)
    !         norm_term_lcf = lcf_ref / (lcf_pnorm**(p_norm_lcf - 1.0))
    !         
    !         ! Local LCF sensitivity: ∂N/∂x ≈ -N²/σ × ∂σ/∂x
    !         ! Higher stress → lower life → higher sensitivity
    !         dLCF_dx = -elemLCF(i)**2 / (elemStress(i) + 1E-6) * elemStress(i)
    !         
    !         ! Combined sensitivity (normalized by constraint)
    !         sensit_g_lcf(i) = power_term_lcf * norm_term_lcf * dLCF_dx / lcf_cycles_min
    !         
    !         ! Penalize void elements
    !         *IF, xe(i), LT, 0.5, THEN
    !             sensit_g_lcf(i) = sensit_g_lcf(i) * 0.1
    !         *ENDIF
    !     *ELSE
    !         sensit_g_lcf(i) = 0
    !     *ENDIF
    ! *ENDDO
    ! 
    ! /COM, LCF sensitivities computed (analytical)
    
    ! History averaging for stability
    *IF, iter, GT, 1, THEN
        *DO, i, 1, numElem
            sensit_C(i) = (sensit_C(i) + sensit_old(i)) / 2
        *ENDDO
    *ENDIF
    
    FINISH

    ! ==================================================================
    ! 5.4: AUGMENTED LAGRANGIAN SENSITIVITY COMBINATION
    ! ==================================================================
    
    sens_C_min = 1E30
    sens_C_max = -1E30
    *DO, i, 1, numElem
        *IF, sensit_C(i), LT, sens_C_min, THEN
            sens_C_min = sensit_C(i)
        *ENDIF
        *IF, sensit_C(i), GT, sens_C_max, THEN
            sens_C_max = sensit_C(i)
        *ENDIF
    *ENDDO
    
    ! Calculate effective Lagrange multipliers
    *IF, g_stress, GT, 0, THEN
        lambda_eff_stress = lambda_stress + mu_stress * g_stress
    *ELSE
        lambda_eff_stress = lambda_stress
    *ENDIF
    
    *IF, g_displ, GT, 0, THEN
        lambda_eff_displ = lambda_displ + mu_displ * g_displ
    *ELSE
        lambda_eff_displ = lambda_displ
    *ENDIF
    
    ! LCF effective multiplier (COMMENTED OUT)
    ! *IF, g_lcf, GT, 0, THEN
    !     lambda_eff_lcf = lambda_lcf + mu_lcf * g_lcf
    ! *ELSE
    !     lambda_eff_lcf = lambda_lcf
    ! *ENDIF
    
    ! Combine sensitivities
    *DO, i, 1, numElem
        sens_C_norm = (sensit_C(i) - sens_C_min) / (sens_C_max - sens_C_min + 1E-10)
        sensit_combined(i) = sens_C_norm
        
        weight_stress = ABS(lambda_eff_stress) / (1 + ABS(lambda_eff_stress))
        sensit_combined(i) = sensit_combined(i) + weight_stress * sensit_g_stress(i)
        
        weight_displ = ABS(lambda_eff_displ) / (1 + ABS(lambda_eff_displ))
        sensit_combined(i) = sensit_combined(i) + weight_displ * sensit_g_displ(i)
        
        ! Add LCF constraint sensitivity (COMMENTED OUT)
        ! weight_lcf = ABS(lambda_eff_lcf) / (1 + ABS(lambda_eff_lcf))
        ! sensit_combined(i) = sensit_combined(i) + weight_lcf * sensit_g_lcf(i)
    *ENDDO
    
    *DO, i, 1, numElem
        sensit_old(i) = sensit_combined(i)
    *ENDDO

    ! ==================================================================
    ! 5.5: APPLY SENSITIVITY FILTER
    ! ==================================================================
    /PREP7
    
    *DO, i, 1, numElem
        sumW  = 0
        sumWS = 0
        
        *DO, k, 1, neighCount(i)
            j = neighList(i, k)
            weight = neighWeight(i, k) * xe(j)
            sumW   = sumW + weight
            sumWS  = sumWS + weight*sensit_combined(j)
        *ENDDO
        
        *IF, sumW, GT, 0, THEN
            sensit_filt(i) = sumWS / sumW
        *ELSE
            sensit_filt(i) = sensit_combined(i)
        *ENDIF
    *ENDDO
    
    ! Connectivity-aware adjustment
    *DO, i, 1, numElem
        *IF, isDesign(i), EQ, 1, THEN
            solidNeighbors = 0
            *DO, k, 1, neighCount(i)
                j = neighList(i, k)
                *IF, xe(j), GT, 0.5, THEN
                    solidNeighbors = solidNeighbors + 1
                *ENDIF
            *ENDDO
            
            connectivityRatio = solidNeighbors / neighCount(i)
            
            *IF, xe(i), GT, 0.5, THEN
                *IF, connectivityRatio, LT, 0.25, THEN
                    sensit_filt(i) = sensit_filt(i) * 0.6
                *ELSEIF, connectivityRatio, LT, 0.4, THEN
                    sensit_filt(i) = sensit_filt(i) * 0.8
                *ENDIF
            *ELSE
                *IF, connectivityRatio, GT, 0.6, THEN
                    sensit_filt(i) = sensit_filt(i) * 1.4
                *ELSEIF, connectivityRatio, GT, 0.45, THEN
                    sensit_filt(i) = sensit_filt(i) * 1.2
                *ENDIF
            *ENDIF
        *ENDIF
    *ENDDO
    
    FINISH

    ! ==================================================================
    ! 5.6: BESO UPDATE SCHEME
    ! ==================================================================
    /PREP7
    
    currentVol = 0
    *DO, k, 1, numDesignElem
        i = designElemIdx(k)
        currentVol = currentVol + xe(i)
    *ENDDO
    volFrac_curr = currentVol / numDesignElem
    volHistory(iter) = volFrac_curr
    
    ! TODO: Dynamic evolution rate based on iteration
    ! *IF, iter, LT, 10, THEN
    !     ER = 0.50
    ! *ELSEIF, iter, GE, 10, AND, iter, LT, 30, THEN
    !     ER = 0.30
    ! *ELSEIF, iter, GE, 30, AND, iter, LT, 50, THEN
    !     ER = 0.20
    ! *ELSE
    !     ER = 0.10
    ! *ENDIF

    *IF, volFrac_curr, GT, volfrac, THEN
        volFrac_tgt = volFrac_curr - ER
        *IF, volFrac_tgt, LT, volfrac, THEN
            volFrac_tgt = volfrac
        *ENDIF
    *ELSE
        volFrac_tgt = volfrac
    *ENDIF
    
    g_vol = volFrac_curr - volfrac
    g_volHistory(iter) = g_vol
    
    ! Find sensitivity range
    sens_min = 1E30
    sens_max = -1E30
    *DO, k, 1, numDesignElem
        i = designElemIdx(k)
        *IF, sensit_filt(i), GT, sens_max, THEN
            sens_max = sensit_filt(i)
        *ENDIF
        *IF, sensit_filt(i), LT, sens_min, THEN
            sens_min = sensit_filt(i)
        *ENDIF
    *ENDDO
    
    ! Bisection to find threshold
    *DO, bisect, 1, 50
        threshold = (sens_min + sens_max) / 2
        
        testVol = 0
        *DO, k, 1, numDesignElem
            i = designElemIdx(k)
            *IF, sensit_filt(i), GE, threshold, THEN
                testVol = testVol + 1
            *ENDIF
        *ENDDO
        testVolFrac = testVol / numDesignElem
        
        *IF, testVolFrac, GT, volFrac_tgt, THEN
            sens_min = threshold
        *ELSE
            sens_max = threshold
        *ENDIF
        
        volError = ABS(testVolFrac - volFrac_tgt)
        *IF, volError, LT, 0.001, THEN
            *EXIT
        *ENDIF
    *ENDDO
    
    ! Update densities
    *DO, k, 1, numDesignElem
        i = designElemIdx(k)
        *IF, sensit_filt(i), GE, threshold, THEN
            xe(i) = 1.0
        *ELSE
            xe(i) = xmin
        *ENDIF
    *ENDDO
    
    FINISH

    ! ==================================================================
    ! 5.7: UPDATE AUGMENTED LAGRANGIAN PARAMETERS
    ! ==================================================================
    
    *IF, g_stress, GT, 0, THEN
        lambda_stress = lambda_stress + lambda_update * mu_stress * g_stress
        *IF, lambda_stress, LT, 0, THEN
            lambda_stress = 0
        *ENDIF
    *ENDIF
    
    *IF, g_displ, GT, 0, THEN
        lambda_displ = lambda_displ + lambda_update * mu_displ * g_displ
        *IF, lambda_displ, LT, 0, THEN
            lambda_displ = 0
        *ENDIF
    *ENDIF
    
    *IF, g_stress, GT, tol_constraint, THEN
        mu_stress = mu_stress * mu_update
        *IF, mu_stress, GT, mu_max, THEN
            mu_stress = mu_max
        *ENDIF
        /COM, Stress penalty increased: Mu_stress = %mu_stress%
    *ENDIF
    
    *IF, g_displ, GT, tol_constraint, THEN
        mu_displ = mu_displ * mu_update
        *IF, mu_displ, GT, mu_max, THEN
            mu_displ = mu_max
        *ENDIF
        /COM, Displacement penalty increased: Mu_displ = %mu_displ%
    *ENDIF
    
    ! LCF parameter updates (COMMENTED OUT)
    ! *IF, g_lcf, GT, 0, THEN
    !     lambda_lcf = lambda_lcf + lambda_update * mu_lcf * g_lcf
    !     *IF, lambda_lcf, LT, 0, THEN
    !         lambda_lcf = 0
    !     *ENDIF
    ! *ENDIF
    ! 
    ! *IF, g_lcf, GT, tol_constraint, THEN
    !     mu_lcf = mu_lcf * mu_update
    !     *IF, mu_lcf, GT, mu_max, THEN
    !         mu_lcf = mu_max
    !     *ENDIF
    !     /COM, LCF penalty increased: Mu_lcf = %mu_lcf%
    ! *ENDIF
    
    lambdaStressHistory(iter) = lambda_stress
    lambdaDisplHistory(iter) = lambda_displ
    muStressHistory(iter) = mu_stress
    muDisplHistory(iter) = mu_displ
    
    ! LCF history (COMMENTED OUT)
    ! lambdaLCFHistory(iter) = lambda_lcf
    ! muLCFHistory(iter) = mu_lcf

    ! ==================================================================
    ! 5.8: CHECK CONVERGENCE
    ! ==================================================================
    
    *IF, iter, GT, conv_window, THEN
        avg1 = 0
        avg2 = 0
        *DO, k, 0, conv_window-1
            idx1 = iter - k
            idx2 = iter - k - conv_window
            *IF, idx2, GT, 0, THEN
                avg1 = avg1 + compliance(idx1)
                avg2 = avg2 + compliance(idx2)
            *ENDIF
        *ENDDO
        avg1 = avg1 / conv_window
        avg2 = avg2 / conv_window
        
        *IF, avg2, GT, 0, THEN
            change = ABS(avg1 - avg2) / avg1
        *ELSE
            change = 1
        *ENDIF
        
        *IF, change, LT, convTol, THEN
            *IF, volFrac_curr, LE, volfrac + 0.001, THEN
                *IF, g_stress, LE, tol_constraint, THEN
                    *IF, g_displ, LE, tol_constraint, THEN
                        ! LCF convergence check (COMMENTED OUT)
                        ! *IF, g_lcf, LE, tol_constraint, THEN
                        converged = 1
                        /COM, ========================================
                        /COM, *** CONVERGED at iteration %iter% ***
                        /COM, Final Compliance = %compliance(iter)%
                        /COM, Final Volume Fraction = %volFrac_curr%
                        /COM, Final P-norm Stress = %stress_pnorm% MPa
                        /COM, Final P-norm Displacement = %displ_pnorm% mm
                        /COM, ========================================
                        
                        finalIter = iter
                        *EXIT
                        ! *ENDIF  ! End LCF check (COMMENTED OUT)
                    *ENDIF
                *ENDIF
            *ENDIF
        *ENDIF
    *ENDIF

    ! ==================================================================
    ! 5.9: WRITE PROGRESS
    ! ==================================================================
    /COM, Iter %iter%: C=%compliance(iter)%, Vol=%volFrac_curr%, Change=%change%
    esel,s,mat,,1
    cm, SOLID_TOPOLOGY_%iter%, ELEM
    allsel
*ENDDO

! ========================================================================
! SECTION 6: POST-PROCESSING
! ========================================================================
/PREP7

ESEL, S, MAT, , 1

/PNUM, ELEM, 0
/NUMBER, 0
/VIEW, 1, 1, 1, 1
/ANG, 1
/REPLOT
EPLOT

CM, SOLID_TOPOLOGY, ELEM
ALLSEL

/COM, ========================================
/COM, BESO DUAL P-NORM OPTIMIZATION COMPLETE
/COM, ========================================
/COM, P-Norm Stress Parameter: %p_norm_stress%
/COM, P-Norm Displacement Parameter: %p_norm_displ%
/COM, Target Volume Fraction: %volfrac%
/COM, Final Compliance: %compliance(iter)%
/COM, Final Volume Fraction: %volFrac_curr%
/COM, Final Max Stress: %maxStress% MPa
/COM, Final P-norm Stress: %stress_pnorm% MPa (Error: %stress_error*100% pct)
*IF, g_stress, LE, tol_constraint, THEN
    /COM, Stress Constraint: SATISFIED
*ELSE
    /COM, Stress Constraint: VIOLATED (%g_stress*100% percent)
*ENDIF
/COM, Final Max Displacement: %maxDispl% mm
/COM, Final P-norm Displacement: %displ_pnorm% mm (Error: %displ_error*100% pct)
*IF, g_displ, LE, tol_constraint, THEN
    /COM, Displacement Constraint: SATISFIED
*ELSE
    /COM, Displacement Constraint: VIOLATED (%g_displ*100% percent)
*ENDIF
/COM, ========================================